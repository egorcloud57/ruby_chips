Избегайте вызовов update, save или других методов, которые создают побочные эффекты для объекта, внутри вашего колбэка. Например, не вызывайте update(attribute: "value") внутри колбэка. Это может изменить состояние модели и может привести к неожиданным побочным эффектам при завершении транзакции. Вместо этого можно безопасно присваивать значения напрямую (например, self.attribute = "value") в before_create / before_update или более ранних колбэках.

after_save запускается и при создании, и при обновлении, но всегда после более специфичных колбэков after_create и after_update, независимо от порядка, в котором выполняются макро-вызовы.

Колбэк before_destroy должен быть размещен перед связями dependent: :destroy (или использовать опцию prepend: true), чтобы убедиться, что они выполняются до того, как записи будут удалены с помощью dependent: :destroy.

after_commit создает гарантии, сильно отличающиеся от after_save, after_update и after_destroy. Например, если случается исключение в after_save, транзакция будет отменена, и данные не сохранятся. Не важно, что произойдет, after_commit может гарантировать, что транзакция уже произошла, и данные были сохранены в базу данных. Подробнее о транзакционных колбэках ниже.

product.touch # updates updated_at/on with current time

Вызов произвольного исключения может прервать код, который предполагает, что save и тому подобное не будут провалены подобным образом. Исключение ActiveRecord::Rollback чуть точнее сообщает Active Record, что происходит откат. Он подхватывается изнутри, но не перевызывает исключение.

Имеются два дополнительных колбэка, которые включаются по завершению транзакции базы данных: after_commit и after_rollback. Эти колбэки очень похожи на колбэк after_save, за исключением того, что они не выполняются пока изменения в базе данных не будут подтверждены или обращены. Они наиболее полезны, когда вашим моделям Active Record необходимо взаимодействовать с внешними системами, не являющимися частью транзакции базы данных.

Когда завершается транзакция, колбэки after_commit и after_rollback вызываются для всех созданных, обновленных или удаленных моделей внутри транзакции. Однако, если какое-либо исключение вызовется в одном из этих колбэков, это исключение всплывет, и любые оставшиеся методы after_commit или after_rollback не будут выполнены. По сути, если код вашего колбэка может вызвать исключение, нужно для него вызвать rescue, и обработать его в колбэке, чтобы позволить запуститься другим колбэкам.

Сам код, выполняемый в колбэках after_commit или after_rollback, не замкнут в транзакцию.